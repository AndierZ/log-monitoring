Producer apps.consumer model
	-	Multiple producers
	-	Multiple consumers with leader election? One primary instance + multiple secondary instances
	-	Binary message over tcp using flat but?
	-	Core library for evaluating log message
	-	Core library for keeping track of stats
	-	Unit tests
	-	Readme and docs


Steps

Define the data model for inputs and outputs
Write producers, generate inputs, send over TCP
	read config to figure out which host:port to connect to
	Define a historical apps.producer which provide a context and timer
Write apps.consumer, apps.consumer inputs over TCP, send to a output sink (write to console log)
	take list of producers to expect
Introduce config to specify how these components should be instantiated
They should be one instance per thread. and know how to connect to each other
Use flat buf for message marshalling


Done - Remove logic around hist/realtime context

Introduce heartbeat
Add core functionality for alerting and stats


Make message building and parser more modulized
Make context actually useful - get time or intput/output stream from it

Add unit tests
Add logic for apps.producer to reconnect
Add docs




Improvements:
	Add a messaging broker
		- Potentially use multicast with guaranteed delivery
 		- Back pressure
		- Leader election
		- Replay on reconnect
	Manage the apps using dockers and kubernetes
        Manage config files separately
        Use flat buffer
